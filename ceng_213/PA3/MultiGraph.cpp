#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

//=======================//
// Implemented Functions //
//=======================//


MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    /* TODO */
    float beta = 0;
    beta = w0*(1-alpha) + w1*alpha;
    
    return beta;
}

const std::vector<GraphVertex>& MultiGraph::getVertexList() const {
    return vertexList;
}
int MultiGraph::getVertexIndex(const std::string& vertexName) const {
    int a=0;
    for (GraphVertex desired : vertexList){
       if (desired.name == vertexName){
           return a;
       }
       a++;
    }
    int invalidIndex = -1;
    return invalidIndex;
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    /* TODO */
    int vertexListSize = vertexList.size();
    for(size_t i=0 ; i<vertexListSize ; i++){
        if (vertexList[i].name==vertexName)throw DuplicateVertexException(vertexName);
    }
    GraphVertex newVertex;
    newVertex.name = vertexName;
    vertexList.push_back(newVertex);
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    /* TODO */

    int vertexIndex = -1;

    for (GraphVertex i : vertexList ){
        if (i.name == vertexName){
            vertexIndex = 5; 
        }
    }
    
    if (vertexIndex == -1) throw VertexNotFoundException(vertexName);
    
    else{
        int vertexIndex = 0;
        for(int i=0 ; i<vertexList.size() ; i++){
            if (vertexList[i].name == vertexName) {
                vertexIndex = i;
                break;
            }
        }
        //remove edilecek vertexi gösteren edgeleri silme
        for (GraphVertex vertexA : vertexList){
            int index = 0;
            for (GraphEdge edgeA : vertexA.edges){
                if(edgeA.endVertexIndex == vertexIndex){
                    vertexA.edges.erase(vertexA.edges.begin()+index);
                    index--;
                }
                index++;
            }
        }
        
        
        std::vector<GraphVertex> filteredVertexList;
        
        for (GraphVertex curr_vert : vertexList){
            
            if(curr_vert.name != vertexName){
                
                for(GraphEdge curr_edge : curr_vert.edges){
                    if(curr_edge.endVertexIndex>vertexIndex) --curr_edge.endVertexIndex;    
                }

                filteredVertexList.push_back(curr_vert);
            }
        }
        vertexList.clear();
        vertexList = filteredVertexList;
    }
}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    /* TODO */
    int isExist = 0;

    for (GraphVertex i : vertexList ){
        if (i.name == vertexFromName) isExist=isExist+3;
        if (i.name == vertexToName) isExist=isExist+6;
    }
    if (isExist==3) throw VertexNotFoundException(vertexToName);
    
    else if (isExist==6 || isExist==0) throw VertexNotFoundException(vertexFromName);
    
    else{
        int to_index=0;
        for (GraphVertex toVertex : vertexList){
            if(toVertex.name == vertexToName) break;
            to_index++;
        }
        
        int from_index=0;
        for (GraphVertex fromVertex : vertexList){
            if(fromVertex.name == vertexFromName) break;
            from_index++;
        }
        
        //vertexlistte geziyo
        for (GraphVertex fromVertex : vertexList){
            //fromvertexi buluyo
            if (fromVertex.name == vertexFromName){
                //fromvertexteki edgelerde geziyo
                for(GraphEdge toEdge : fromVertex.edges){
                    //eğer fromvertex ve to vertex arasında edge varsa
                    if(toEdge.endVertexIndex == to_index){
                        //eğer bu edge'in ismi eklemek istediğimizle aynıysa
                        if(toEdge.name == edgeName) throw SameNamedEdgeException(edgeName,vertexFromName,vertexToName);
                    }
                }
                GraphEdge newEdge;
                newEdge.endVertexIndex = to_index;
                newEdge.weight[0] = weight0;
                newEdge.weight[1] = weight1;
                newEdge.name = edgeName;
                vertexList[from_index].edges.push_back(newEdge);
            } 
            
        }
    }
}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    /* TODO */
    int isExist = 0;

    for (GraphVertex i : vertexList ){
        if (i.name == vertexFromName) isExist=isExist+3;
        if (i.name == vertexToName) isExist=isExist+6;
    }
    if (isExist==3) throw VertexNotFoundException(vertexToName);
    
    else if (isExist==6 || isExist==0) throw VertexNotFoundException(vertexFromName);
    
    else{
        
        int to_index=0;
        for (GraphVertex toVertex : vertexList){
            if(toVertex.name == vertexToName) break;
            to_index++;
        }
        
        int a=0;
        //vertexlistte geziyo
        for (GraphVertex& fromVertex : vertexList){
            //fromvertexi buluyo
            if(fromVertex.name == vertexFromName){
                //fromvertexteki edgelerde geziyo ve 
                std::vector<GraphEdge> updatedEdge;
                for(GraphEdge toEdge : fromVertex.edges){
                    // remove edilecek edge hariç diğerlerini updatedEdge e ekliyo
                    if (!(toEdge.name == edgeName && toEdge.endVertexIndex == to_index)){
                        updatedEdge.push_back(toEdge);
                    }
                    else a=1;
                }
                if (a==0) throw EdgeNotFoundException(vertexFromName,edgeName);
                fromVertex.edges.clear();
                fromVertex.edges = updatedEdge;
            }
        }
    }
}
void MultiGraph::HeuristicHelper(std::vector<GraphVertex> &visited,
                                std::vector<GraphVertex> &verticesForTable, 
                                std::vector<float> &ShortestDistFrom,
                                std::vector<GraphVertex> &PreviousVertexForTable,
                                int fromIndex,
                                float heuristicWeight,
                                std::vector<int> &edgeIndex) const
{
    for (GraphVertex isThere : visited) {
        if (isThere.name == vertexList[fromIndex].name) return;
    }
    
    int edgeForTable=0;
    
    for (GraphEdge edge : verticesForTable[fromIndex].edges){
        float beta = Lerp(edge.weight[0],edge.weight[1],heuristicWeight);
        
        if (ShortestDistFrom[edge.endVertexIndex]>ShortestDistFrom[fromIndex]+beta){
                
                ShortestDistFrom[edge.endVertexIndex] = ShortestDistFrom[fromIndex]+beta;
                edgeIndex[edge.endVertexIndex] = edgeForTable;
                PreviousVertexForTable[edge.endVertexIndex] = verticesForTable[fromIndex];
                
        }
        edgeForTable++;
    }
    
    visited.push_back(verticesForTable[fromIndex]);
    
    MinPairHeap<int,float> minHeap;
    
    for (GraphEdge nbhEdge : verticesForTable[fromIndex].edges){
        int newFromIndex = nbhEdge.endVertexIndex;
        minHeap.push({newFromIndex,ShortestDistFrom[newFromIndex]});
    }
    while(!minHeap.empty()){
        int a = minHeap.top().key;
        minHeap.pop();
        HeuristicHelper(visited,
                        verticesForTable,
                        ShortestDistFrom,
                        PreviousVertexForTable,
                        a,
                        heuristicWeight,
                        edgeIndex);
    }
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    /* TODO */
    std::vector<GraphVertex> visited;
    std::vector<GraphVertex> verticesForTable;
    std::vector<float> ShortestDistFrom;
    std::vector<GraphVertex> PreviousVertexForTable;
    std::vector<int> edgeIndex;
    
    for (GraphVertex i : vertexList){
        verticesForTable.push_back(i);
        ShortestDistFrom.push_back(999999999);
        edgeIndex.push_back(-1);
    }
    
    for (GraphVertex n : vertexList){
        GraphVertex tenno;
        tenno.name = "bosch";
        PreviousVertexForTable.push_back(tenno);
    }
    
    int varMi = 0;
    int fromIndex = 0;
    for (GraphVertex fromVertex : vertexList){
        if (fromVertex.name == vertexNameFrom){ 
            varMi = 1;
            break;
        }
        fromIndex++;
    }
    if (varMi == 0) throw VertexNotFoundException(vertexNameFrom);
    
    int varMi_2 = 0;
    int toIndex = 0;
    for (GraphVertex toVertex : vertexList){
        if (toVertex.name == vertexNameTo){ 
            varMi_2 = 1;
            break;
        }
        toIndex++;
    }
    if (varMi_2 == 0) throw VertexNotFoundException(vertexNameTo);
    
      
    ShortestDistFrom[fromIndex] = 0;
    edgeIndex[fromIndex] = 0;
    
    HeuristicHelper(visited,
                    verticesForTable,
                    ShortestDistFrom,
                    PreviousVertexForTable,
                    fromIndex,
                    heuristicWeight,
                    edgeIndex);
    if (ShortestDistFrom[toIndex] == 999999999) return false;
    
    else{
        std::vector<int> reverseOrderedVertexEdgeIndexList;
        // from'u ekleyene kadar dönüyo
        int sabitFromIndex = fromIndex;
        
        while(sabitFromIndex!=toIndex){
            reverseOrderedVertexEdgeIndexList.push_back(toIndex);
            reverseOrderedVertexEdgeIndexList.push_back(edgeIndex[toIndex]);
            int newToIndex=0;
            for(GraphVertex k: vertexList){
                if (PreviousVertexForTable[toIndex].name == k.name) break;
                newToIndex++;
            }
            toIndex = newToIndex;
        }
        
        reverseOrderedVertexEdgeIndexList.push_back(toIndex);
        int sizeOfReverse = reverseOrderedVertexEdgeIndexList.size();
        for (int k=sizeOfReverse-1 ; k>=0 ; k--){
            orderedVertexEdgeIndexList.push_back(reverseOrderedVertexEdgeIndexList[k]);
        }
        return true;
    }
}

void MultiGraph::FilteredHelper(std::vector<GraphVertex> &visited,
                                std::vector<GraphVertex> &verticesForTable, 
                                std::vector<float> &ShortestDistFrom,
                                std::vector<GraphVertex> &PreviousVertexForTable,
                                int fromIndex,
                                float heuristicWeight,
                                std::vector<int> &edgeIndex,
                                const std::vector<std::string>& edgeNames) const
{
    for (GraphVertex isThere : visited) {
        if (isThere.name == vertexList[fromIndex].name) return;
    }
    int edgeForTable=0;
    for (GraphEdge edge : verticesForTable[fromIndex].edges){
        float beta = Lerp(edge.weight[0],edge.weight[1],heuristicWeight);
        int yasakli = 0;
        for (int i=0 ; i<edgeNames.size(); i++){
            if (edgeNames[i] == edge.name){
                yasakli = 1;
            }
        }
        if (yasakli);
        else{
            if (ShortestDistFrom[edge.endVertexIndex]==999999999){
                
                ShortestDistFrom[edge.endVertexIndex] = ShortestDistFrom[fromIndex]+beta;
                edgeIndex[edge.endVertexIndex] = edgeForTable;
                PreviousVertexForTable[edge.endVertexIndex] = verticesForTable[fromIndex];
            }
        
            else if (ShortestDistFrom[edge.endVertexIndex]>ShortestDistFrom[fromIndex]+beta){
                
                ShortestDistFrom[edge.endVertexIndex] = ShortestDistFrom[fromIndex]+beta;
                edgeIndex[edge.endVertexIndex] = edgeForTable;
                PreviousVertexForTable[edge.endVertexIndex] = verticesForTable[fromIndex];
            }
             
        }
        edgeForTable++; 
    }
    visited.push_back(verticesForTable[fromIndex]);
    for (GraphEdge nbhEdge : verticesForTable[fromIndex].edges){
        int newFromIndex = nbhEdge.endVertexIndex;
        FilteredHelper(visited,
                        verticesForTable,
                        ShortestDistFrom,
                        PreviousVertexForTable,
                        newFromIndex,
                        heuristicWeight,
                        edgeIndex,
                        edgeNames);
    }    
}


bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    /* TODO */
    std::vector<GraphVertex> visited;
    std::vector<GraphVertex> verticesForTable;
    std::vector<float> ShortestDistFrom;
    std::vector<GraphVertex> PreviousVertexForTable;
    std::vector<int> edgeIndex;
    
    for (GraphVertex i : vertexList){
        verticesForTable.push_back(i);
        ShortestDistFrom.push_back(999999999);
        edgeIndex.push_back(-1);
    }
    
    for (GraphVertex n : vertexList){
        GraphVertex tenno;
        tenno.name = "bosch";
        PreviousVertexForTable.push_back(tenno);
    }
    
    int varMi = 0;
    int fromIndex = 0;
    for (GraphVertex fromVertex : vertexList){
        if (fromVertex.name == vertexNameFrom){ 
            varMi = 1;
            break;
        }
        fromIndex++;
    }
    if (varMi == 0) throw VertexNotFoundException(vertexNameFrom);
    
    int varMi_2 = 0;
    int toIndex = 0;
    for (GraphVertex toVertex : vertexList){
        if (toVertex.name == vertexNameTo){ 
            varMi_2 = 1;
            break;
        }
        toIndex++;
    }
    if (varMi_2 == 0) throw VertexNotFoundException(vertexNameTo);
    
      
    ShortestDistFrom[fromIndex] = 0;
    edgeIndex[fromIndex] = 0;
    
    FilteredHelper(visited,
                    verticesForTable,
                    ShortestDistFrom,
                    PreviousVertexForTable,
                    fromIndex,
                    heuristicWeight,
                    edgeIndex,
                    edgeNames);
                    
    if (ShortestDistFrom[toIndex] == 999999999) return false;
    
    else{
        std::vector<int> reverseOrderedVertexEdgeIndexList;
        // from'u ekleyene kadar dönüyo
        int sabitFromIndex = fromIndex;
        
        while(sabitFromIndex!=toIndex){
            reverseOrderedVertexEdgeIndexList.push_back(toIndex);
            reverseOrderedVertexEdgeIndexList.push_back(edgeIndex[toIndex]);
            int newToIndex=0;
            for(GraphVertex k: vertexList){
                if (PreviousVertexForTable[toIndex].name == k.name) break;
                newToIndex++;
            }
            toIndex = newToIndex;
        }
        
        reverseOrderedVertexEdgeIndexList.push_back(toIndex);
        int sizeOfReverse = reverseOrderedVertexEdgeIndexList.size();
        for (int k=sizeOfReverse-1 ; k>=0 ; k--){
            orderedVertexEdgeIndexList.push_back(reverseOrderedVertexEdgeIndexList[k]);
        }
        return true;
    }
}

int MultiGraph::BiDirectionalEdgeCount() const
{
    /* TODO */
    
    int count = 0;
    int mInt=0;
    for (GraphVertex m : vertexList){
        for(GraphEdge n : m.edges){
            for (GraphEdge s : vertexList[n.endVertexIndex].edges){
                if (s.endVertexIndex == mInt && s.name==n.name){
                    count++;
                }
            }
        }
        mInt++;
    }
    count = count/2;
    return count;
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{
    /* TODO */
    std::vector<int> visited;
    MinPairHeap<int,int> minHeap;
    int varMi = 0;

    int fromIndex = 0;
    for (GraphVertex n : vertexList) {
        if (n.name == vertexName) {
            varMi = 1;
            break;
        }
        fromIndex++;
    }

    if (varMi == 0) throw VertexNotFoundException(vertexName);

    minHeap.push({0,fromIndex});
    visited.push_back(fromIndex);
    
    int maxDepth = -1;
    
    
    while (!minHeap.empty()) {
        auto current = minHeap.top();
        minHeap.pop();
        int currentDepth = current.key;
        int vertexIndex = current.value;

        for (GraphEdge n : vertexList[vertexIndex].edges){
            
            if (n.name == edgeName){
                int neighborIndex = n.endVertexIndex;
                int inVisited = 0;
                for (int i=0; i<visited.size();i++){
                    if (visited[i]==neighborIndex){
                        inVisited = 1;
                    }   
                }
                if(!inVisited){
                    minHeap.push({currentDepth + 1, neighborIndex});
                    visited.push_back(neighborIndex);   
                    if (currentDepth + 1 > maxDepth) maxDepth = currentDepth + 1; 
                }
            }
        }
    }
    return maxDepth;
}